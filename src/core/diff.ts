import {
  Column,
  DatabaseSchema,
  DiffResult,
  Operation,
  StateColumn,
  StateFile,
} from '../types/types';

/**
 * Extract table names from a stored state file.
 */
export function getTableNamesFromState(state: StateFile): Set<string> {
  return new Set(Object.keys(state.tables));
}

/**
 * Extract table names from a database schema.
 */
export function getTableNamesFromSchema(schema: DatabaseSchema): Set<string> {
  return new Set(Object.keys(schema.tables));
}

/**
 * Extract column names from a state table columns record.
 */
export function getColumnNamesFromState(
  stateColumns: Record<string, StateColumn>
): Set<string> {
  return new Set(Object.keys(stateColumns));
}

/**
 * Extract column names from a schema table columns array.
 */
export function getColumnNamesFromSchema(dbColumns: Column[]): Set<string> {
  return new Set(dbColumns.map(column => column.name));
}

function getSortedNames(names: Set<string>): string[] {
  return Array.from(names).sort((a, b) => a.localeCompare(b));
}

function normalizeColumnType(type: string): string {
  return type
    .toLowerCase()
    .trim()
    .replace(/\s+/g, ' ')
    .replace(/\s*\(\s*/g, '(')
    .replace(/\s*,\s*/g, ',')
    .replace(/\s*\)\s*/g, ')');
}

function resolveStatePrimaryKey(table: StateFile['tables'][string]): string | null {
  return table.primaryKey ??
    Object.entries(table.columns).find(([, column]) => column.primaryKey)?.[0] ??
    null;
}

function resolveSchemaPrimaryKey(table: DatabaseSchema['tables'][string]): string | null {
  return table.primaryKey ?? table.columns.find(column => column.primaryKey)?.name ?? null;
}

/**
 * Compare a persisted state and a new schema, generating ordered operations.
 */
export function diffSchemas(oldState: StateFile, newSchema: DatabaseSchema): DiffResult {
  const operations: Operation[] = [];

  const oldTableNames = getTableNamesFromState(oldState);
  const newTableNames = getTableNamesFromSchema(newSchema);

  const sortedNewTableNames = getSortedNames(newTableNames);
  const sortedOldTableNames = getSortedNames(oldTableNames);

  // Phase 1: create tables (A-Z)
  for (const tableName of sortedNewTableNames) {
    if (!oldTableNames.has(tableName)) {
      operations.push({
        kind: 'create_table',
        table: newSchema.tables[tableName],
      });
    }
  }

  const commonTableNames = sortedNewTableNames.filter(tableName =>
    oldTableNames.has(tableName)
  );

  // Phase 2: detect column type changes in schema order
  for (const tableName of commonTableNames) {
    const newTable = newSchema.tables[tableName];
    const oldTable = oldState.tables[tableName];

    if (!newTable || !oldTable) {
      continue;
    }

    for (const column of newTable.columns) {
      const previousColumn = oldTable.columns[column.name];
      if (!previousColumn) {
        continue;
      }

      const previousType = normalizeColumnType(previousColumn.type);
      const currentType = normalizeColumnType(column.type);

      if (previousType !== currentType) {
        operations.push({
          kind: 'column_type_changed',
          tableName,
          columnName: column.name,
          fromType: previousColumn.type,
          toType: column.type,
        });
      }
    }
  }

  // Phase 3: drop PK constraints for changed/removed primary keys
  for (const tableName of commonTableNames) {
    const newTable = newSchema.tables[tableName];
    const oldTable = oldState.tables[tableName];

    if (!newTable || !oldTable) {
      continue;
    }

    const previousPrimaryKey = resolveStatePrimaryKey(oldTable);
    const currentPrimaryKey = resolveSchemaPrimaryKey(newTable);

    if (previousPrimaryKey !== null && previousPrimaryKey !== currentPrimaryKey) {
      operations.push({
        kind: 'drop_primary_key_constraint',
        tableName,
      });
    }
  }

  // Phase 4: detect unique changes for existing columns in schema order
  for (const tableName of commonTableNames) {
    const newTable = newSchema.tables[tableName];
    const oldTable = oldState.tables[tableName];

    if (!newTable || !oldTable) {
      continue;
    }

    for (const column of newTable.columns) {
      const previousColumn = oldTable.columns[column.name];
      if (!previousColumn) {
        continue;
      }

      const previousUnique = previousColumn.unique ?? false;
      const currentUnique = column.unique ?? false;

      if (previousUnique !== currentUnique) {
        operations.push({
          kind: 'column_unique_changed',
          tableName,
          columnName: column.name,
          from: previousUnique,
          to: currentUnique,
        });
      }
    }
  }

  // Phase 5: add columns in schema order
  for (const tableName of commonTableNames) {
    const newTable = newSchema.tables[tableName];
    const oldTable = oldState.tables[tableName];

    if (!newTable || !oldTable) {
      continue;
    }

    const oldColumnNames = getColumnNamesFromState(oldTable.columns);

    for (const column of newTable.columns) {
      if (!oldColumnNames.has(column.name)) {
        operations.push({
          kind: 'add_column',
          tableName,
          column,
        });
      }
    }
  }

  // Phase 6: add PK constraints for added/changed primary keys
  for (const tableName of commonTableNames) {
    const newTable = newSchema.tables[tableName];
    const oldTable = oldState.tables[tableName];

    if (!newTable || !oldTable) {
      continue;
    }

    const previousPrimaryKey = resolveStatePrimaryKey(oldTable);
    const currentPrimaryKey = resolveSchemaPrimaryKey(newTable);

    if (currentPrimaryKey !== null && previousPrimaryKey !== currentPrimaryKey) {
      operations.push({
        kind: 'add_primary_key_constraint',
        tableName,
        columnName: currentPrimaryKey,
      });
    }
  }

  // Phase 7: drop columns in state key order
  for (const tableName of commonTableNames) {
    const newTable = newSchema.tables[tableName];
    const oldTable = oldState.tables[tableName];

    if (!newTable || !oldTable) {
      continue;
    }

    const newColumnNames = getColumnNamesFromSchema(newTable.columns);

    for (const columnName of Object.keys(oldTable.columns)) {
      if (!newColumnNames.has(columnName)) {
        operations.push({
          kind: 'drop_column',
          tableName,
          columnName,
        });
      }
    }
  }

  // Phase 8: drop tables (A-Z)
  for (const tableName of sortedOldTableNames) {
    if (!newTableNames.has(tableName)) {
      operations.push({
        kind: 'drop_table',
        tableName,
      });
    }
  }

  return { operations };
}
